# スクリプティング
この節では、もっぱらJavaScriptを扱う`script`要素について説明をします。
## `script`要素
`script`要素は、主に動的なスクリプト（通常はJavaScript）を埋め込んだり参照したりする要素です。
<!-- spec: 4.12.1 -->

### `src` 属性とインラインスクリプト
`src`属性は外部スクリプトのURLを指定します。文書にスクリプトを直接埋め込む代わりに使用できます。`src`属性を指定しなければ、インラインに埋め込まれたスクリプトが解釈されます。なお、インラインのスクリプトを埋め込み、かつ`src`属性を指定した場合は、外部スクリプトが読み込まれ、インラインスクリプトは無視されます。

`src`属性を用いた、外部スクリプトの指定例は次のようになります。

```
<script src="a.js">
```

とても古いブラウザーでは`script`要素が解釈できず、中身がそのまま表示されるために、コメントアウトするという次のコード例のような手法が存在しました。

```
<mark>古いHTMLの悪い例</mark>
<script language="javascript">
<!--
    window.alert("test")
// -->
</script>
```
ECMAScript 2015では、互換性のためにHTML-likeコメントが仕様に追加されました。HTML-likeコメントは、HTMLのコメント区切り子をECMAScriptの1行コメントして解釈するよう定めています（つまり、`//`と同じ効力を持つことになります）。なお、モダンブラウザーでは当然ながら`script`要素を解釈できるため、このように書く必要はありません。

<mark class="comment">何かセキュリティ関連で言うべきことがあれば、追加する</mark>

### `type` 属性による判別
`script`要素は、指定されるtype属性によって、その処理方法が変わります。仕様では、クラシックスクリプト、モジュールスクリプト、データブロックの3つに分類されます。

#### クラシックスクリプト
通常のJavaScriptです。
type属性を省略するか、空にする、もしくはMIME Sniffing標準に定められたJavaScript MIME typeエッセンシャルマッチとなるもの（例えば、`text/javascript`）を指定すると、`script`要素はクラシックスクリプトとして処理されます。
なお、古いHTMLでは`type`属性は必須でしたが、現在では省略可能です。クラシックスクリプトを意図する場合は冗長なだけでなので、省略してしまいましょう。
また、さらに古いHTMLでは`language`属性が`type`属性の代わりに指定されることがありましたが、`language`属性は現在廃止されています。古いHTMLをメンテナンスする際に見かけたときは、削除してしまいましょう。

#### モジュールスクリプト
ECMAScript 2015で新たに導入された、ES Modulesとして動作するJavaScriptです。モジュールスクリプトとして動作させるためには、`type="module"`を指定します。ES Modulesを解釈できないブラウザーのために、フォールバックとなる手段を提供する必要がありますが、この目的のために`nomodule`属性が存在します。`nomodule`属性を指定すると、モジュールスクリプトをサポートするブラウザーでは、そのスクリプトを無視します。
<!--
どこかでECMAScriptの簡単な説明（次のようなもの）をしておきたいが、どこですべきか？
JavaScriptは、Ecma Internationalという標準化団体により標準化がされているECMAScriptの実装です。ECMAScriptには版（edition）があり、現在は発行年で区別されています。発行年で区別するようになったECMAScript 2015から、毎年6月に新しい版に更新されています。
-->

```
<script type=module src=app.js></script>
<script nomodule src=classic-app.mjs</script>
```

このように記述すれば、モジュールスクリプトを解釈できるブラウザーは、モジュールスクリプトとしてapp.jsのみを実行し、モジュールスクリプトを解釈できないブラウザーは、クラシックスクリプトとしてclassic-app.jsのみを実行します。

#### データブロック
`type`属性にJavaScript MIME typeエッセンシャルマッチとならない、妥当なMIME typeが設定されると、データブロックを意味します。ブラウザーは要素の中身を処理しません。

<!--
スペックから例を持ってくるべきか、
https://ginpen.com/2011/12/22/built-any-data/
こんな感じのそれっぽいスクリプトもどきも書くべきか。
-->
<!--コードはspecからのコピー-->
次のコードはデータブロックの一例です。
```
<script src="game-engine.js"></script>
<script type="text/x-game-map">
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
</script>
```

JSON-LDによるメタデータ埋め込みもデータブロックに該当します。JSON-LDについてはx.x節を参照してください。<!-- どこで説明？ -->

### `async` 属性および `defer` 属性
`async`属性および`defer`属性はスクリプトをどのように評価すべきかを示す真偽属性です。通常、スクリプトに出くわすと、HTMLの解析が止まってしまいます。しかし、これらの属性を指定することで、HTMLの解析をブロックすることなく、スクリプトを読み込むことが出来るようになります。スクリプトが実行されるタイミングは、スクリプトの種類によって異なります。

![async属性とdefer属性の違いを示した図](https://html.spec.whatwg.org/images/asyncdefer.svg)
<!--要日本語化-->

<!-- 超速本P.102あたりも参照 -->

`DOMContentLoaded`の説明は必要。

<!-- specの複写ここから -->
async — ブロックなしで、可能な場合にスクリプトを実行する
defer — スクリプトの実行を延期する

asyncおよびdefer属性は、どのようにスクリプトが評価されるべきかを示す真偽属性である。クラシックスクリプトは、deferまたはasyncを指定してもよいが、src属性が存在しない限り、いずれかを指定してはならない。モジュールスクリプトはasync属性を指定してもよいが、defer属性を指定してはならない。

クラシックスクリプトについて、async属性が存在する場合、クラシックスクリプトは、構文解析と並行してフェッチされるとすぐに（潜在的に構文解析が完了する前に）利用可能になると評価される。asyncが存在しないがdefer属性が存在する場合、クラシックスクリプトは、並行してフェッチされ、ページが解析終了した際に評価される。いずれの属性も存在しない場合、スクリプトは、両方が完了するまで解析を阻止して、すぐにフェッチされ評価される。

モジュールスクリプトについて、async属性が存在する場合、モジュールスクリプトとそのすべての依存関係は、構文解析と並行してフェッチされ、モジュールスクリプトは利用可能になるとすぐに（潜在的に構文解析が完了する前に）評価される。そうでなければ、モジュールスクリプトとその依存関係は、構文解析と並行してフェッチされ、ページが解析終了した際に評価される。（defer属性は、モジュールスクリプトに影響しない。）

<!-- specの複写ここまで -->


## `noscript`要素
`noscript`要素は、スクリプトが無効である場合に、その子要素を表示します。言い換えると、なんらかの場合にブラウザーでJavaScriptが無効になっている場合に、この要素を用いることでフォールバックコンテンツを提供できるということです。
例えば、スクロールしてから画像が表示されるような場所に配置される`img`要素に対して、JavaScriptを用いて遅延読み込み（Lazy load）を行う場合、次のような`noscript`要素のコードを記述することで、JavaScriptが無効な環境でも画像を表示させることができます。

```
<img src="blank.jpg" data-src="target.jpg" alt="">
<noscript><img src="target.jpg" alt=""></noscript>
```

## `template`要素

`template`要素は、主にJavaScriptによて文書に挿入できるHTMLの断片を宣言するために使用します。レンダリングでは、`template`要素自身は何も表しません。

この`template`要素は、テンプレートという名前が示すとおり、ウェブページ上で同じ構造を繰り返し使用する場合に効果を発揮します。コード例を示します。

```
<table>
 <thead>
   <tr>
     <th>名前</th>
     <th>学名</th>
     <th>開花期</th>
   </tr>
 </thead>
 <tbody id="importtable">
 </tbody>
</table>

<template id="productrow">
 <tr>
   <td></td><td></td><td></td><td></td>
 </tr>
</template>

<script>
let data = [
     { name: 'アガパンサス', latin: 'Agapanthus', season: '5月下旬～8月上旬' },
     { name: 'クレマチス', latin: 'Clematis', season: '4月中旬～10月' },
     { name: 'コスモス', latin: 'Cosmos', season: '6月～11月' },
     { name: 'ミスミソウ', latin: 'Hepatica nobilis', season: '2月下旬～5月上旬' }
 ];

 // templete要素のcontent属性の有無を確認して、
 // ブラウザーがHTML template要素に対応しているかをテスト
 if ("content" in document.createElement("template")) {
   // 既存のHTML tbodyとtemplateの行を用いてインスタンス生成
   let template = document.querySelector("#productrow");
   // 新しい行を複製して表に挿入
   for (var i = 0; i < data.length; i += 1) {
     let cat = data[i];
     let tbody = document.querySelector("#importtable");
     let clone = document.importNode(template.content, true);
     let cells = clone.querySelectorAll("td");
     cells[0].textContent = cat.name;
     cells[1].textContent = cat.latin;
     cells[2].textContent = cat.season;
     tbody.appendChild(clone);
   }
 } else {
 // HTML template要素に対応していない場合の処理
 }
</script>
```
<!--
https://developer.mozilla.org/ja/docs/Web/HTML/Element/template
https://dekiru.net/article/12865/
をもとに作成。-->

コード例では、`tbody`要素の子孫のテンプレートを`template`要素に記述し、`template`要素に流し込むデータについては、JavaScriptの配列に記載しています。スクリプトでは、`document.importNode()`メソッドを用いてノード（ここではテーブルの行）のクローンを作成し、`appendChild()`メソッドでノードの追加を行っています。

